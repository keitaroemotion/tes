#!/usr/bin/env ruby

require "colorize"

ARGV.empty? && abort("you need argument [all][set][path]")

def kill_processes(root_dir)
  # kill (initialize) processes of each modules
  [
    "postgres",
    "redis-server",
    "elasticsearch",
    "rails",
    "#{root_dir}/bin/rails",
  ].each do |process|
    system "ps aux | grep #{process} | awk '{print}' | xargs kill -9 "
  end
end

def get_log_location
  "log/result.log"
end

def execute_shell(command, delay = 0, log = get_log_location)
  puts delay == 0 ? "" : "sleep #{delay}..."
  system "sleep #{delay}"
  puts "\n[executing..]#{command.red} >> #{log.green}\n"
  system "#{command} "
  puts "\n[done!]#{command}\n".green
end

# renew logfile
execute_shell "rm #{get_log_location};"

def setter_array(root_dir)
  kill_processes root_dir
  [
    # server / database setups
    ["elasticsearch &", 0],
    ["postgres -D /usr/local/var/postgres &", 0],
    ["redis-server /usr/local/etc/redis.conf &", 0],
    ["#{root_dir}/bin/rake db:create db:schema:load &", 5],
    # gateway launching
    ["#{root_dir}/bin/rails s -p4500 &", 10],
    # seed database
    ["#{root_dir}/bin/rake db:seed --trace &", 15],
    # elastic server launching
    ["#{root_dir}/bin/rake elasticsearch:import:bulk &", 25],
  ]
end

def unit_test()
  [["bundle exec ruby -I test #{ARGV[0]} #{ARGV[1]} #{ARGV[2]}", 0]]
end

def get_test_plan(option, root_dir)
  return [["#{root_dir}/bin/rake test:all ", 0]] if option == "all"
  return setter_array(root_dir) if option == "set"
  return unit_test if /^(all|set)$/.match(option).nil?
end

root_dir = "."
# calling shell scripts simultaneously.
# the integer value of each array element is start time delay
# (for these commands have execution orders)
Thread.new do
  get_test_plan(ARGV[0], root_dir).each do |order|
    # [0] command [1] start delay time
    execute_shell order[0], order[1]
  end
end.join

system "afplay /System/Library/Sounds/Ping.aiff"
